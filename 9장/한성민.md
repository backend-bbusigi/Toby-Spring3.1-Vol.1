# 9.3장_애플리케이션 아키텍처

> 💡
>
> 아키텍처는 “어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것” 이다.

# 계층형 아키텍처

성격이 다른 모듈이 강하게 결합되어 모여있으면, 한 가지 이유로 변경이 일어날 때 그와 상관 없는 요소도 함께 영향을 받는다.

→ `인터페이스`와 같은 유연한 경계를 만들어 분리하거나, 모아주는 작업이 필요하다.

애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진 것들끼리 묶을 수 있다.

`example`

데이터 액세스 로직을 담당하는 DAO를 하나의 단위로 생각하기, 비즈니스 로직을 구현해놓은 비즈니스 서비스 오브젝트를 같은 성격으로 묶기.

따라서 성격이 다른 것은 `아키텍처 레벨`에서 분리해주는 게 좋다.

`분리를 통한 이점`

- 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능하다.
- 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경할 수 있다.

→ 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해둔 것을 `계층형 아키텍처`라고 부른다.

## 3계층 아키텍처와 수직 계층

![Image](https://github.com/user-attachments/assets/ece4383d-474b-4e5b-b4c2-f1f0c36264d5)

- DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 `데이터 액세스` 계층
- 비즈니스 로직을 담고 있는 `서비스` 계층
- 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 `프레젠테이션` 계층

### 데이터 액세스 계층 (DAO 계층)

장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임

데이터 액세스 계층은 사용 기술에 따라 세분화된 계층으로 구분된다.

같은 책임을 가지지만 추상화 레벨에 따라 구분하기 때문에 `수직적인 계층`이라고도 한다.

![Image](https://github.com/user-attachments/assets/f77ce8b4-6726-4ffb-b929-2767865a6cc4)

### 서비스 계층

- 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다.
  ← 객체지향적인 설계 기법이 적용된 코드(POJO)를 통해서 비즈니스 로직의 핵심을 잘 담아낸다.
- 서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다.

![Image](https://github.com/user-attachments/assets/a2befc30-d935-4d82-92fb-4f0a77ffe939)

- 기반 서비스 계층이 서비스 계층의 오브젝트를 호출하는 경우
    - 일반적으로 서비스 계층이 필요에 따라 기반 서비스 계층의 API를 호출해서 이용한다.
    - 서비스 계층의 코드를 기반 서비스 계층에서 실행시키는 경우도 존재한다.
        - ex. 스케줄링
        - 이런 경우, AOP를 통해 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법도 생각해볼 수 있다.

### 프레젠테이션 계층

클라이언트와 연결돼서 동작하는 프레젠테이션 계층은 자바에서 `HTTP 프로토콜`을
처리하는 가장 기본 엔진이 `서블릿 기술`을 바탕으로 한다.

### 계층형 아키텍처 설계의 원칙

- 각 계층은 `응집도가 높으면서` 다른 계층과는 `낮은 결합도`를 유지한다.
- 각 계층은 `자신의 계층의 책임`에만 충실해야 한다.

# 애플리케이션 정보 아키텍처

---

애플리케이션의 주요 상태 정보는 클라이언트나 백엔드 시스템에 분산돼서 보관된다.

> **데이터 중심 아키텍처**
>
- 애플리케이션을 사이에 두고 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조다.
    - DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현하고 값을 그대로 화면과 연결하는 것을 의미한다.

### DB/SQL 중심의 로직 구현 방식

`데이터 중심 아키텍처 특징`

하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다.

`example`

사용자 이름으로 사용자 정보를 검색해서 일치하는 사람의 아이디, 비밀번호, 이름, 가입일자를 보여주는 작업

- 검색 조건은 SQL로 생성.
- 조회 페이지에 보여줄 네 가지 정보를 담을 수 있는 단순한 오브젝트로 저장되어 전달.

→ 바로 가져오기 때문에 서비스 계층은 할 일이 별로 없다.

→ 모든 계층의 코드는 “이름을 이용한 고객을 조회한다”에 종속된다.

![Image](https://github.com/user-attachments/assets/1df8de70-ba84-4069-8fe0-e9aa284e5c5f)

DB 중심의 아키텍처는 개발 하기 쉬운 장점만 있을 뿐, 객체지향의 장점을 별로 활용할 수  없을 뿐더러, 스프링의 장점을 제대로 누릴 수 없다.

### 거대한 서비스 계층 방식

![Image](https://github.com/user-attachments/assets/8f0843ca-a36b-41d3-b3e4-b094322a91bd)

DB 중심의 아키텍처의 단점을 극복하기 위해선 복잡한 SQL을 피하면서 `주요 로직은 서비스 계층에서 처리`하도록 만드는 것이다.

DAO에서 좀 더 단순한 결과를 돌려줌으로써, 돌려준 정보에 비즈니스 로직을 적용할 수 있다. 이를 통해 DAO와 SQL은 단순해지고, 일부는 여러 서비스 계층에서 재사용 할 수 있다.

하지만 업무 트랜잭션 단위로 서비스 계층의 메소드가 만들어질 가능성이 높은데, 이 경우 하나의 메소드가 매우 거대해질 수 있다.

→ 비즈니스 로직의 대부분이 서비스 계층에 집중된 `거대한 서비스 계층`을 만들게 된다.

`장점`

- 애플리케이션 코드에 비즈니스 로직이 담겨있어 자바 언어의 장점을 활용해 로직을 구현할 수 있다.
- 테스트하기 수월하다.
- SQL이 복잡하지 않다.
- 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다.
- 초기 개발 속도가 빠르다.
- 개발자 사이에 간섭없이 독립적인 개발이 가능하다.

`단점`

- SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. (계층간의 결합도 UP)
- 비슷한 기능의 코드가 여러 메소드에서 중복될 수 있다.

# 오브젝트 중심 아키텍처

---

`도메인 모델`을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는데 사용한다.

→ 오브젝트 중심 아키텍처는 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다.

도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖기 때문에 일관된 구조를 유지한 채로 사용될 수 있다.

### 도메인 오브젝트를 사용하는 코드

오브젝트 중심 방식에서 비즈니스 로직의 구현은 간단하고 명확하다.

만약 카테고리에 포함된 상품의 모든 가격을 계산해야 한다면 `서비스 계층의 오브젝트` 안에 메소드를 만들어 사용한다.

`장점`

- 도메인 모델을 앎으로써, 메소드의 행위를 이해하기 수월해진다.
- 해당 기능이 필요하다면 어디에서든지 그 기능의 메소드를 사용하면 된다.

`문제`

- 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수할 수 있다.
    - SQL의 프로젝션을 통해 필요한 컬럼만 가져올 수 있는 반면, 도메인 오브젝트는 모든 필드 정보를 채워서 전달해야 한다.
- 오브젝트의 연관 관계에서 연관된 오브젝트까지 다 조회해서 가져오는 문제가 발생한다.
    - 만약 연관된 오브젝트만 가져오게 한다면, 아닌 필드는 Null 값이 들어가고 NPE가 발생할 수 있다.
    - `지연 로딩(Lazy Loading)` 기법을 이용하면 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 동적으로 읽어올 수 있다.
    - 가장 이상적인 방법은 JPA, 하이버네이트와 같은 ORM 기술을 사용하는 것이다.

### 빈약한 도메인 오브젝트

![Image](https://github.com/user-attachments/assets/3d950a47-5053-4b90-a394-88ed37bc9f52)

도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않다면 이를 `빈약한(anemic) 오브젝트`라 부른다.

빈약한 도메인의 비즈니스 로직은 `서비스 계층`에 존재한다.

→ 데이터 중심 아키텍처의 거대 서비스 계층 구조와 비슷하다.

→ 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어있어 재사용성이 떨어지고, 중복 문제가 발생하기 쉽다.

### 풍성한 도메인 오브젝트

![Image](https://github.com/user-attachments/assets/2023f868-42cb-476e-8b5b-2bef2f9c515f)

빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것을 `풍성한 도메인 오브젝트`라고 한다.

비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있다.

이런 로직을 서비스 계층이 아닌 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만든다. (`도메인 메소드`)

`장점`

- 이 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다.
- 로직이 포함된 서비스를 DI할 필요가 없다.

> ⚠️
>
> 서비스 계층은 그럼 필요 없는 게 아닐까?
>
> 그렇지 않다.
>
> 도메인 메소드는 도메인 오브젝트나, 연관된 오브젝트만을 활용하기 때문에, 여러 종류의 도메인 오브젝트의 기능을 조합해서 복잡한 비즈니스 로직을 만들 경우, `서비스 계층의 오브젝트`에 두는 것이 적당하다.

### 도메인 계층 방식

![Image](https://github.com/user-attachments/assets/04a67b9a-4058-497e-bb16-ab6ac1bf43cd)

도메인 계층의 역할과 비중을 극대화하기 위해 기존의 풍성한 도메인 오브젝트 방식으론 만족하기 힘들다.

→ 하나의 계층을 이루게 하는 `도메인 계층 방식`이 등장했다.

`차이점`

1. 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아닌 도메인 계층의 오브젝트 안에서 진행된다.
2. 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다.

도메인 오브젝트는 도메인 계층에서만 상주하며, 도메인 계층 밖으로 전달될 때는 DTO를 사용하여 전달한다.

> 💡
>
> **DTO (Data Transfer Object)**
>
> - 데이터 전달 오브젝트
> - 상태 변화 허용 X
> - 읽기 전용
> - 기능을 갖지 않는다.

도메인 계층의 오브젝트는 매우 짧은 시간 동안만 존재헀다가 사라지는 것을 반복한다.

(각 요청 별로 독립적으로 도메인 오브젝트가 `생성`됐다가 요청 `처리` 후 `버려진다`.)

# 스프링 애플리케이션을 위한 아키텍처 설계

---

## 계층형 아키텍처

스프링에서 가장 많이 사용되는 구조다.

`프레젠테이션 계층` : Spring MVC

`서비스 계층` : POJO로 구현 + 트랜잭션 AOP

`데이터 액세스 계층` : JDBC, JPA, 하이버네이트 등 활용

## 정보 전송 아키텍처

도메인 오브젝트를 사용해 애플리케이션의 정보를 일관된 형태로 유지하는 것이 스프링에 가장 잘 들어 맞는 방식이다.

## 상태관리와 빈 스코프

서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태를 갖지 않는다. (`무상태`, `stateless`)

하지만 어떤 식으로든 애플리케이션의 상태와 작업 정보는 유지돼야 한다. 이렇게 상태를 저장, 유지하는 데 스프링은 `상태가 유지되지 않는 빈과 오브젝트`를 사용하는 것을 권장한다.
