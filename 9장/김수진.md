# 9장 스프링 프로젝트 시작하기

# 3. 애플리케이션 아키텍처

## 계층형 아키텍처

> 어플리케이션을 **비슷한 역할을 하는 그룹으로 나누어 계층을 형성**하는 방식
> 

⇒  각 계층이 독립적으로 개발되고 테스트될 수 있으며, 유지보수가 쉬워진다.

### **3계층 아키텍처와 수직 계층**

![image](https://github.com/user-attachments/assets/cfabef03-0ca3-4a9f-a198-60a96cfcc5cd)


### **데이터 액세스 계층 (DAO 계층)**

![image](https://github.com/user-attachments/assets/dcb372dd-03ad-4845-b5d5-0e0f393b1a3f)

> 데이터베이스와의 직접적인 인터페이스를 담당하는 계층
> 
- `jdbcTemplate`을 활용하여 JDBC의 복잡성을 줄이고 효율적으로 데이터에 접근할 수 있다.
- 필요한 경우 추가적인 추상화 계층을 도입하여 DAO 코드를 단순하게 할 수 있다.

### **서비스 계층**

![image](https://github.com/user-attachments/assets/c9e0e37e-a13f-4a35-b03c-218937703d3f)


> 비즈니스 로직을 처리하고 DAO 계층과 프레젠테이션 계층을 연결하는 중간 역할
> 
- `POJO` 방식으로 구현해서 객체지향적인 설계를 적용해야 한다.
- 비즈니스 로직을 명확하게 구성하고, 필요하면 메시징 서비스나 시스템 기반 서비스를 활용할 수도 있다.
- 특정 구현 기술에 종속되지 않도록 **인터페이스를 통해 접근하는 방식**을 사용하는 것이 좋다.

### **프레젠테이션 계층**

> **사용자 인터페이스(UI)를 담당하며, 클라이언트와 상호작용하는 계층**
> 
- HTTP 프로토콜을 기반으로 서블릿(Servlet)이 주로 사용된다.
- 최근에는 프레젠테이션 로직이 클라이언트 측(JavaScript, React, Vue 등)으로 이동하는 경향이 강해지고 있다.

## 애플리케이션 정보 아키텍처

애플리케이션 정보 아키텍처는 **데이터를 다루는 방식**과 **비즈니스 로직의 위치**에 따라 크게 두 가지로 나뉜다.

### DB/SQL 중심의 로직 구현 방식

![image](https://github.com/user-attachments/assets/87541a67-580c-4e1c-b6cc-78d38cb4d55d)

- 핵심 비즈니스 로직을 **SQL과 DB 내부의 저장 프로시저**에 포함시킨다.
- **서비스 계층의 역할이 적고**, DAO에서 가져온 SQL 결과를 단순히 변환하여 전달하는 역할을 한다.
- **프레젠테이션 계층**에서 SQL의 결과를 1:1로 매핑하여 사용한다.

📍 **장점**

- SQL과 DB에 익숙한 개발자들이 쉽게 개발할 수 있다.
- 초기 개발 속도가 빠르고, 개발 자동화 도구를 활용하기 용이하다.

📍 **단점**

- **모든 계층이 특정 업무 트랜잭션 단위로 강하게 결합된다.**
- **테스트하기 어렵고 유지보수가 힘들다.** SQL이 변경되면 모든 계층이 영향을 받는다.
- **확장성이 부족하다.** DB에 부하가 집중되며, 비즈니스 로직을 재사용하기 어렵다.

### 거대한 서비스 계층 방식

![image](https://github.com/user-attachments/assets/d12e2da3-8e0f-4e66-9f44-aea309b5f943)



- **SQL을 단순하게 유지하고, 비즈니스 로직을 서비스 계층에서 처리한다.**
- **DAO는 단순한 SQL 실행만 담당하고**, 서비스 계층이 데이터를 가공한다.
- 객체지향적 설계를 적용할 기회가 많아진다.

📍 **장점**

- 핵심 로직이 **Java 코드로 표현되므로 유지보수가 용이하다.**
- **SQL이 단순해지고, DAO가 일부 재사용 가능하다.**
- **테스트가 용이하다.** POJO 기반의 코드 작성이 가능하다.

📍 **단점**

- **서비스 계층이 너무 커질 위험이 있다.** → "거대한 서비스 계층(Fat Service Layer)" 문제 발생 가능.
- 비즈니스 로직을 재사용하기 어려울 수도 있다.
- 개발자의 코드 스타일에 따라 품질이 달라질 위험이 있다.

## 오브젝트 중심 아키텍처

오브젝트 중심 아키텍처는 데이터를 단순히 값으로 다루는 것이 아니라, **도메인 모델을 반영한 오브젝트 구조를 사용하여 정보를 전달하고 활용하는 방식**이다. 이를 통해 **객체지향 설계의 장점을 극대화**할 수 있다.

### 데이터와 오브젝트

> 애플리케이션에서 사용되는 정보를 **도메인 모델 기반의 오브젝트에 담아 계층 간에 전달**한다.
> 

도메인 모델을 기반으로 **객체 간 관계를 정의**하며, SQL 결과를 직접 사용하는 방식과 차별화된다.

📍 **장점**

- **일관된 정보 구조**를 유지할 수 있다.
- **계층 간 결합도를 낮추고**, 데이터 구조의 변경이 있어도 코드 수정이 줄어든다.

📍 **단점**

- SQL 결과를 변환하는 과정이 필요하여 **성능 저하**가 발생할 수 있다.
- 객체 관계를 유지하는 데 **추가적인 메모리와 로직이 필요**할 수 있다.

### 빈약한 도메인 오브젝트 방식


![image](https://github.com/user-attachments/assets/faf38eda-633b-4e02-a75e-677b6c2c4ee4)



> 도메인 오브젝트는 있지만 **비즈니스 로직 없이 단순한 데이터 저장용 역할**을 한다.
> 

**모든 비즈니스 로직은 서비스 계층에서 처리**한다.

📍 **장점**

- **구조가 단순하여 이해하기 쉽고 개발 속도가 빠르다.**
- **3계층 구조를 유지할 수 있어 계층 분리가 명확하다.**

📍 **단점**

- **서비스 계층이 비대해지고, 코드 중복이 발생할 가능성이 높다.**

### 풍성한 도메인 오브젝트 방식

![image](https://github.com/user-attachments/assets/a1cd8970-3d9d-4db6-a47e-47c86657442a)



> 도메인 오브젝트 내부에 **비즈니스 로직을 포함하여 객체 자체가 기능을 수행할 수 있도록 한다.**
> 

**서비스 계층에서는 도메인 오브젝트의 메서드를 호출하여 활용**하며, 로직의 응집도가 높아진다.

📍 **장점**

- **객체의 재사용성이 높아지고, 서비스 계층의 코드가 간결해진다.**
- **객체 내부에 필요한 로직이 포함되므로 유지보수가 용이하다.**

📍 **단점**

- 도메인 오브젝트가 **스프링 빈이 아니므로 DI(의존성 주입)를 받을 수 없다.**
- 객체 자체가 로직을 수행하기 때문에 **잘못 설계되면 코드가 난잡해질 위험이 있다.**

### 도메인 계층 방식

![image](https://github.com/user-attachments/assets/7536d5c1-9757-4438-9ecf-eaa504ac7f77)


> **도메인 계층을 별도로 두어 핵심적인 비즈니스 로직을 담당하도록 설계**한다.
> 

도메인 오브젝트가 서비스 계층과 데이터 액세스 계층 사이에서 독립적으로 작동한다.

📍 **장점**

- **비즈니스 로직을 도메인 계층에서 관리할 수 있어 응집도가 높아진다.**
- **도메인 모델과 설계 변경에 유연하게 대응할 수 있다.**
- **테스트가 용이하며 객체지향 설계를 최대한 활용할 수 있다.**

📍 **단점**

- **설계가 복잡하고 개발 초기 부담이 크다.**
- **DTO를 활용하여 데이터 전달을 해야 할 수도 있다.**

## 스프링 애플리케이션을 위한 아키텍처 설계

### 계층형 아키텍처

- 필요에 따라 **서비스 계층과 데이터 액세스 계층을 통합**할 수도 있다.
- MVC 패턴을 사용하면 **프레젠테이션 계층을 효과적으로 분리**할 수 있다.

### 정보 전송 아키텍처

- **오브젝트 중심 아키텍처**를 적용하면 도메인 오브젝트를 일관되게 유지할 수 있다.
- 도메인 오브젝트를 활용하면 **코드 재사용성과 유지보수성이 향상**된다.

### **상태 관리와 빈 스코프**

- 스프링은 **무상태(stateless) 방식**을 기본으로 하지만, 세션·쿠키·DB를 활용한 상태 저장도 가능하다.
- **HTTP 세션**을 활용하면 단기적인 상태 저장이 가능하다.
- **빈 스코프 설정**을 통해 사용자별·요청별 독립적인 상태 관리가 가능하다.