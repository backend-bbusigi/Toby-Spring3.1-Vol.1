# 1. 스프링 애플리케이션
## 1.1 클라이언트 / 백엔드
- 애플리케이션의 기본 구조
    - 클라이언트 : 웹 브라우저
    - 백엔드 : DB
    - 즉 DB를 사용하는 웹 어플리케이션
- 하나의 스프링 애플리케이션이 여러 종류의 클라이언트에게 동시에 서비스를 제공하는 경우도 있음
- 백엔드 시스템이 여러 DB를 동시에 사용하거나 여러 종류의 백엔드 시스템을 이용하는 것도 가능함

![스크린샷 2025-01-28 오후 6.55.58.png](attachment:f5a84915-5581-45ae-a056-088f187198d0:스크린샷_2025-01-28_오후_6.55.58.png)

<br>

## 1.2 애플리케이션 서버

> 스프링으로 만든 애플리케이션을 자바 서버 환경에 배포하려면 JavaEE 서버가 필요함

### 1.2.1 JavaEE 서버

1. 경량급 WAS / 서블릿 컨테이너
    - 스프링은 톰캣/제타 같은 서블릿 컨테이너만 있어도 충분함
2. WAS
    - 성능 면에서 안전성, 리소스 관리, 레거시 시스템의 연동이 필요하다면 사용할 수 있음
    - 모니터링 기능이 뛰어나 여러 대의 서버를 동시에 운영할 때 유리함
    - JavaEE 표준을 최대한 활용할 수 있음


### 1.2.2 스프링소스 tcServer

- 아파치 톰캣 : 가장 많이 사용되는 자바 서버이며 웹 모듈만 지원하는 서블릿 컨테이너임
- 스프링소스의 개발자들은 톰캣을 기반으로 경량급 애플리케이션 서버인 tsServer을 개발함
    - 스프링 개발/운영에 필요한 기능이 많이 제공되고 있으며 개발을 위해서라면 자유롭게 이용 가능함

<br>

## 1.3 스프링 애플리케이션의 배포 단위
### 1.3.1 독립 웹 모듈

- `war`로 패키징된 독립 웹 모듈을 배포함
    - 서블릿 컨테이너를 쓴다면 유일한 방법임

### 1.3.2 엔터프라이즈 애플리케이션
- 경우에 따라 확장자가 `ear`인 애플리케이션으로 패키징해 배포함
- EJB 모듈을 이용해야 한다면 모듈을
-  엔터프라이즈 애플리케이션으로 통합해야 함

### 1.3.3 백그라운드 서비스 모듈
- rar 패키징 : 리소스 커넥터를 만들어 배포
- J2EE 1.4 이상의 표준을 따르는 WAS가 반드시 필요함

<br><br>

# 2. 개발도구와 환경
## 2.1 JavaSE / JavaEE

- **JavaSE / JDK**
    - 스프링 3.0 : JavaSE 5버전의 특징을 활용해 개발됨
    - 일부 기능은 JDK 6.0 API를 이용해 개발됨
- **JavaEE / J2EE**
    - 스프링 3.0 : J2EE 1.4 버전 / JavaEE 5.0 버전이 요구됨
    - J2EE 1.4를 사용할 경우 JDK 5.0에서 동작하는지 확인해야 함
        - WAS가 JDK 5.0을 사용할 수 없다면 스프링 3.0 사용은 불가함

<br>

## 2.2 라이브러리 관리

### 2.2.1 라이브러리 관리의 어려움

- 많게는 수십 개씩의 의존 라이브러리가 필요하나 항상 모든 라이브러리가 필요한 것은 아님
    - 라이브러리의 버전과 서로의 호환성에 따라 문제가 발생하기도 함
- 모듈의 개념이 없음
    - 같은 패키지/이름을 가졌으나 구현이 다른 클래스 파일 a.jar, b.jar 가정
        - 모두 클래스패스에 있을 때, a, b 중 어느 것을 사용할지 선택할 수 없음
    - jar은 압축 패키징 방법일 뿐 구분 가능한 독립된 모듈이 아님
- 위의 문제를 재패키징을 통해 해결할 수 있음
    - 한 쪽 버전의 클래스를 다른 패키지로 옮겨 서로 구별되는 클래스로 만들어줌
    - 스프링은 라이브러리를 재패키징해 `org.springframework.` 패키지 아레에 두고 사용함

### 2.2.2 라이브러리 선정

- 스프링 모듈
    - 총 20개의 모듈이 있으며 일부는 필수 일부는 선택적임
    - 모듈 사이의 의존관계가 있으며 필수/선택으로 구분됨
- 라이브러리
    - 스프링 모듈은 라이브러리를 의존할 수도 있음
    - 각 라이브러리를 활용하는 방법에 따라 다른 서드파티 라이브러리를 필요로 하는 경우도 있음

### 2.2.3 빌드 툴과 라이브러리 관리

- Maven
    - 빌드 툴이자 테스트, 배치, 문서화 등 다양한 작업을 지원하는 종합 프로젝트 관리 툴임
    - POM : 프로젝트 모델 정보
        - 필요한 정보를 POM으로 만들어두면 이를 이용해 빌드를 진행함
        - 애플리케이션이 필요로 하는 의존 라이브러리를 선언해두기만 하면 원격 서버에서 이를 자동으로 다운로드 받아 사용할 수 있게 해줌
    - 전이적 의존 라이브러리 추적 기능
        - POM에 라이브러리를 지정하면 해당 라이브러리가 동작하는 데 필요한 여타 라이브러리까지 함께 다운로드해줌
        - 선택 라이브러리는 해당되지 않음
            - 참고는 가능하나 사용하려면 명시적 선언이 필요함
    - 스프링의 모든 모듈은 POM 정보를 가지고 있음

<br><br>

# 3. 애플리케이션 아키텍쳐
## 3.1 계층형 아키텍쳐

이전까지는 오브젝트 레벨에서 분리 문제를 해결했음 

성격이 다른 코드를 두 오브젝트로 분리하고 그 사이에 인터페이스를 두고 DI를 이용해 오브젝트끼리 직접적인 관계를 알지 못하도록 했음

이러한 특징을 더 넓게 혹은 좁게 확장할 수 있음

- 계층형 아키텍쳐
    - 책임/성격이 다른 것을 크게 그룹을 나누어 분리해두는 아키텍쳐
    - 멀티 티어 아키텍쳐
    - 3계층 애플리케이션 (전형적)

### 3.1.1 3계층 아키텍쳐

- 데이터 액세스 계층
    - DB 레거시 시스템과 연동하는 인터페이스
    - DAO 계층 = EIS 계층
    - 수직적 계층
        - 추상화 수준에 따른 구분이며 추가 및 제거 가능
- 서비스 계층
    - 비즈니스 로직 함유
        - 이상적인 POJO로 작성됨
    - DAO 계층을 호출하고 활용해 만들어짐
    - 추상화 수직 계층구조를 가질 필요가 없음
    - 기반 서비스와 서로 API를 사용할 수 있음
        - 스케쥴링과 같은 기능은 기반 서비스 계층이 서비스 계층의 오브젝트를 이용함
    - 인터페이스를 통해서만 접근하도록 만들어 특정 구현/기술에 대한 종속성을 제거해야 함
    - 데이터 액세스 / 프레젠테이션 계층이 바뀌어도 그대로 유지될 수 있어야 함
- 프레젠테이션 계층
    - 웹 기반의 UI를 만들고 흐름을 관리
    - 다양한 기술과 프레임워크의 조합을 가질 수 있음
        - 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트 종류와 관계없이 HTTP를 사용하는 서블릿을 기반으로 함
    - 클라이언트까지 범위를 확장할 수 있음
        - RIA / SOFEA

![스크린샷 2025-01-28 오후 9.05.52.png](attachment:ed1b41ef-85e8-4c24-b073-b405b52f0ed8:스크린샷_2025-01-28_오후_9.05.52.png)

### 3.1.2 계층형 아키텍쳐 설계 원칙

- 각 계층은 응집도가 높으면서도 다른 계층과는 낮은 결합도를 유지할 수 있어야 함
    - 각 계층은 자신의 계층의 책임에만 충실해야 함
- 다른 계층을 호출할 때는 인터페이스를 사용하며, 이 때 기술이 최대한 드러나지 않게 만들어야 함
    - [좋지 못한 예시] ResultSet이라는 데이터 액세스 계층에서 만들어진 오브젝트를 서비스 계층에 다루어야 함
        
        ```java
        public ResultSet findUsersByName(String name) throws SQLException；
        ```
        
    - [해결 예시] 기술 종속적 예외 대신 런타임 예외를 throw하도록 수정
        
        ```java
        public List<User> findUsersByName(String name) throws DataAccessException；
        ```
        
- 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하면 안됨
    - `HttpServletRequest`, `HttpSession`과 같은 타입을 특정 계층에 종속되지 않는 오브젝트 형태로 변환해야 함

<br>

## 3.2 애플리케이션 정보 아키텍쳐

- 애플리케이션을 사이에 두고 이동하는 정보를 어떻게 다룰 것인가
    - 데이터로 다룰지
        - 데이터 중심 아키텍쳐 → 비즈니스 로직이 DB 내부에 저장되어 있음
    - 오브젝트로 다룰지

### 3.2.1 DB/SQL 중심의 로직 구현

- 하나의 업무 트랜잭션에 모든 게층의 코드가 종속됨
    - 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경됨
    - 코드의 재사용이 어려우며 SQL 자체가 업무마다 다르게 작성되어야 함
- 자바 코드를 DB-웹을 연결하는 단순한 인터페이스 도구로 전략시킬 뿐임
- 변화에 매우 취약하며 중복을 제거하기 어려워 확장에 한계가 있음

### 3.2.2 거대한 서비스 계층 방식

- 비즈니스 로직을 애플리케이션 코드로 옮겨 객체지향의 장점을 살리며 개발을 할 수 있음
    - DAO, SQL은 더 단순해지고 일부는 재사용이 가능해짐
- 서비스 계층이 매우 두꺼워지며 메소드 중복이 일어나기 쉬움
    - DAO의 결과에 따라 취급 방법이 달라짐

<br>

## 3.3 오브젝트 중심 아키텍쳐

도메인 모델을 반영하는 오브젝트 구조를 만들어두고 각 계층에서 정보를 전송하는 데 사용함

- 도메인 모델을 오브젝트 모델로 활용
- DB entity 설계에도 반영되기 때문에 entity 구조와 유사할 가능성이 높음

### 3.3.1 데이터와 오브젝트

- 데이터 중심 아키텍쳐
    - SQL, DB 관점에서 생각함
    - 두 테이블을 JOIN을 이용해 2차원 구조의 정보를 만듦
    - 데이터 결과를 `List<Map<String, Object>>` 에 담아 서비스 계층에 전달함
    - SQL/DB를 바꾸면 서비스/프레젠테이션 계층 코드도 바뀌어야 함
    - DAO는 전달되는 데이터의 구조를 모두 알고 있어야 함
- 오브젝트 중심 아키텍쳐
    - 도메인 모델은 전 계층에서 동일한 의미를 가지므로 일관된 구조로 사용할 수 있음
    - 다른 오브젝트를 참조해 관계를 표현할 수 있음
    - 서비스 계층은 오브젝트 형태를 이용하기만 하면 되기 때문에 SQL에 대해 알 필요가 없음

### 3.3.2 도메인 오브젝트 사용의 문제점

- SQL 사용에 비해 성능이 좋지 않음
- 비즈니스 로직에 따라 필요한 정보가 달라질 수 있어 도메인 필드의 모든 정보를 채우는 것은 비효율적임
- 레퍼런스를 참조하고 있는 데이터까지 모두 조회하는 것은 비효율적임

1. 지연된 로딩
    - 최소한의 오브젝트 정보만 읽어두고 필요한 경우 관계된 오브젝트를 DB에서 읽어 옴
2. 필요한 필드에 대해 오브젝트 생성
    - DTO를 이용해 필요한 필드만을 가지는 오브젝트를 만들어 사용
3. RDB 매핑 기술
    - ORM
        - JPA, JDO, 하이버네이트
    - 기본적으로 lazy loading을 지원하며 복잡한 DAO 코드를 요구하지 않음
    - 자주 사용하는 레퍼런스 테이블을 ORM의 오브젝트 캐시에 담아두고 사용할 수 있음

### 3.3.3 빈약한 도메인 오브젝트 방식

- 빈약한 오브젝트 : 도메인 오브젝트에 정보만 담겨 있고 정보를 활용하는 기능이 없음
- 서비스 계층에서 이용할 핵심 비즈니스 로직만 가지고 있음
    - 거대 서비스 계층 방식 중 하나
- 재사용성이 떨어지고 중복을 피할 수 없음

### 3.3.4 풍성한 도메인 오브젝트 방식

- 특정 도메인 오브젝트와 깊은 관계가 있는 비즈니스 로직을 도메인 오브젝트에 넣도록 함
- 도메인 오브젝트는 DAO 오브젝트를 DI받을 수 없음
    - 도메인 오브젝트는 빈이 아니기 때문
    - 따라서 서비스 계층이 필요함

![스크린샷 2025-01-28 오후 10.35.30.png](attachment:631187fd-7e36-43ca-9356-5c662f3da696:스크린샷_2025-01-28_오후_10.35.30.png)

### 3.3.5 도메인 계층 방식

- 도메인 오브젝트의 레벨을 격상시켜 하나의 계층을 이루게 함
- 비즈니스 로직은 도메인 계층의 오브젝트 안에서 진행됨
    - 서비스 계층의 도움 없이 비즈니스 로직 대부분을 수행할 수 있음
- 도메인 오브젝트가 기존 3계층의 기능을 직접 활용할 수 있음
    - 여전히 빈이 아니지만 AOP를 이용해 DI받아 사용함
    - AspectJ AOP - 오브젝트의 생성자가 호출되며 만들어지는 시점을 조인 포인트로 사용할 수 있으며 일반 오브젝트에도 AOP를 적용할 수 있음
- 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야 함
    1. 여전히 모든 계층에서 도메인 오브젝트를 사용
        - 오브젝트 중심 아키텍쳐의 장점을 누릴 수 있음
        - 중요한 비즈니스 로직을 함부로 호출할 수 있기 때문에 위험함
    2. 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 함
        - DTO를 이용해 타 계층으로 데이터를 전달
        - 기능을 갖지 않으므로 안전하나 매번 변환해줘야 하는 번거로움이 있음

![스크린샷 2025-01-28 오후 10.45.32.png](attachment:a7c03b35-5adc-4fe0-bcff-45298ac630d2:스크린샷_2025-01-28_오후_10.45.32.png)

<br>

## 3.4 스프링 애플리케이션을 위한 아키텍쳐 설계
### 3.4.1 계층형 아키텍쳐

- 가장 많이 사용됨
- 손쉽게 핵심 데이터 로직만 남은 DAO를 만들 수 있음
- DAO를 인터페이스로 치부하고 서비스-프레젠테이션 계층을 통합할 수도 있음
    - AOP를 이용해 트랜잭션 경계를 설정하기가 애매해지기 때문에 권장되지 않음

- 프레젠테이션 계층 - MVC 패턴
- 서비스 계층 - POJO + 트랜잭션 AOP 적용
- 데이터 액세스 계층 - JPA, 하이버네이트 … 를 활용