# 8장_스프링이란 무엇인가?

---

# 1. 스프링의 정의

---

>❗
>
> 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크

## 애플리케이션 프레임워크

`일반적인 라이브러리, 프레임워크`

- 특정 업무 분야나 한 가지 기술에 특화된 목표를 가지고 만들어진다.

`애플리케이션 프레임워크`

- 특정 계층이나, 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크
- 애플리케이션 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는데 목표를 둔다.

### 스프링이 애플리케이션 프레임워크가 된 이유

스프링의 기원은 로드 존슨의 `Expert One-on-One J2EE Design and Development` 라는 책의 예제 코드에서 시작된다.

예제 애플리케이션의 프레임워크는 자바 엔터프라이즈 개발의 전 계층에 등장하는 기술과 애플리케이션의 전 영역에 대한 효과적인 설계와 개발 기법을 다루고 있다.

→ 이 예제 프레임워크로부터 시작된 스프링은 자연스럽게 애플리케이션의 전 영역을 지원하는 종합적인 애플리케이션 프레임워크가 되었다.

> ⚠️
>
> 단지 여러 계층의 다양한 기술을 모아뒀기 때문이 아닌, 애플리케이션의 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로 각 분야의 특성에 맞는 필요를 채워주기 때문에 애플리케이션 프레임워크라 부른다.


## 경량급

여기서 말하는 경량급은

- 스프링 자체가 가볍다. (X)
- 작은 규모의 코드로 이뤄졌다. (X)

가 아니다.

### 스프링이 경량급인 이유

`EJB`

- 스프링 등장 전의 자바 주류 기술인 `EJB`는 개발환경과 운용 서버, 테스트 과정 등 모두를 매우 무겁고 복잡하게 만들었다.
- 또한 동작하려면 스프링에서 사용하는 `WAS`인 톰캣이나 제티를 사용하는 것이 아닌 고가의 느리고 무거운 `WAS` 를 사용했다.
- EJB와 WAS같은 기술과 환경을 지원하기 위해 반복되는 코드가 존재한다.

↔

`Spring`

- 스프링은 가장 단순한 WAS인 톰캣이나 제티에서 완벽하게 동작한다. (그만큼 개발 과정이 단순)
- 기술과 환경을 지원하기 위한 반복되는 코드가 제거됐다.

→ 만들어진 코드가 지원하는 기술 수준은 비슷하더라도, 그것을 훨씬 빠르고 간편하게 작성하게 해줌으로써 생산성과 품질 면에서 유리한 것을 `경량급`이라 표현할 수 있다.

## 자바 엔터프라이즈 개발을 편하게

스프링은 개발자들이 스프링 프레임워크가 제공하는 기술이 아닌, 자신이 작성한 애플리케이션의 로직에 더 많은 관심과 시간을 쏟게 해준다.

즉 기술적인 복잡함과 그에 따른 수고를 제거해준다.

## 오픈소스

스프링은 오픈소스 프로젝트 방식으로 개발돼왔다.

오픈소스 프로젝트이기 때문에, 개발 과정에서 많은 사람이 자유롭게 참여할 수 있다.

# 2. 스프링의 목적

---

## 엔터프라이즈 개발의 복잡함

1. 기술적인 제약 조건과 요구사항이 늘어난다.
- 엔터프라이즈 시스템은 많은 사용자의 요청을 동시에 처리하기 때문에, 서버의 자원을 효율적으로 공유하고 분배해서 사용해야 한다.
- 또한 중요한 기업의 핵심 정보를 처리하는 등 보안과 안정성, 확장성 면에서도 뛰어나야 한다.

→ 엔터프라이즈 시스템을 개발하는 데는 순수한 비즈니스 로직 뿐만 아니라 기술적으로 고려할 사항이 많다.

2. 엔터프라이즈 애플리케이션이 구현해야 할 핵심기능인 비즈니스 로직의 복잡함이 증가한다.
- 시간이 갈수록, 엔터프라이즈 시스템을 이용해 기업의 핵심 업무를 처리하는 비율이 늘어나고, 컴퓨터를 이용하지 않고는 아예 진행할 수 없을 만큼 힘들어졌다.

복잡함을 가중시키는 원인은 비즈니스 로직의 복잡함과 기술적인 복잡함이다.

## 해결책

### 실패한 해결책 : EJB

EJB의 기본 전략은 위 두가지 복잡함을 분리하는 것이었다.

하지만 EJB 환경에서 동작하기 위해 특정 인터페이스를 구현하고 특정 클래스를 상속하는 등, EJB의 개발 방식을 따라야 했다. (종속)

### 효과적인 해결책 : 스프링

EJB처럼 어떤 기술을 적용했을 때 그 기술과 관련된 코드나 규약 등이 코드에 등장하는 경우를 `침투적인 기술`이라 한다.

스프링은 `비침투적인 기술`의 전략을 택했기 때문에 성공할 수 있었다.

→ 기술적인 복잡함과 비즈니스 로직을 다루는 코드를 깔끔하게 분리할 수 있다.

## 복잡함을 상대하는 스프링의 전략

### 기술적 복잡함을 상대하는 전략

1. 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다.

환경, 서버, 조건 등이 변경됨에 따라, 코드도 바뀌는 것은 심각한 문제이다. (코드를 일일이 변경해야 하는 번거로움 발생)

→ 일관성 없는 기술과 서버환경의 변화에 대한 스프링의 공략 방법은 바로 `서비스 추상화(PSA)`다.

기술적인 복잡함을 `추상화`를 통해 로우 레벨의 기술 구현 부분과 기술을 사용하는 `인터페이스를 분리`하고, 환경과 세부 기술에 `독립적인 접근 인터페이스`를 제공하는 것이 가장 좋은 해결책이다.

2. 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다.

비즈니스 로직 전후로 경계가 설정돼야 하는 트랜잭션, 비즈니스 로직에 대한 보안 적용 등의 `비즈니스 로직의 혼재`로 발생하는 `복잡함을 해결`하기 위해 **AOP**를 사용한다.

AOP를 사용하여 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 깔끔하게 분리해서 별도의 모듈로 관리할 수 있다.

### 비즈니스, 애플리케이션 로직의 복잡함을 상대하는 전략

비즈니스 로직은 업무의 변화에 따라 자주 변경되거나 수정되고, 복잡한 데이터를 분석하고 그에 따른 작업을 수행한다.

즉 비즈니스 로직은 가장 중요하게 다뤄져야 하고 가장 많이 신경써야 한다.

→ 엔터프라이즈 시스템 개발의 흐름은 점차로 비즈니스 로직은 `애플리케이션 안에서 처리`하도록 만든다.

# 3. POJO 프로그래밍

---

<img width="365" alt="Image" src="https://github.com/user-attachments/assets/e33a8ab9-d46c-495d-8075-4c1442077a47" />

> 스프링 애플리케이션

`POJO`를 이용해서 만든 `애플리케이션 코드` + POJO가 어떻게 `관계를 맺고 동작`하는지를 정의한 `설계 정보`

## POJO란?

> **POJO (Plain Old Java Object)**

마틴 파울러가 2000년에 컨퍼런스 발표를 준비하다가 만들어낸 용어.

평범한 자바 오브젝트에 EJB와 같이 그럴싸한 이름이 없었는데, 이를 있어 보이도록 만들기 위해 POJO라는 이름을 붙였다.

## POJO의 조건

1. 특정 규약에 종속되지 않는다.

POJO는 자바 언어와 꼭 필요한 API 외에 종속되지 않아야 한다.

만약 특정 규약에 따라 만들게 되는 경우는 대부분 규약에서 제시하는 특정 클래스를 상속하도록 요구한다. (자바는 단일 상속 제한때문에 더이상 해당 클래스에 설계 기법을 적용하기 어렵다.)

`객체지향 설계의 자유로운 적용이 가능한 오브젝트`여야만 POJO라고 부를 수 있다.

2. 특정 환경에 종속되지 않는다.

POJO는 환경에 독립적이어야 한다.

> ⚠️
>
> 애노테이션을 사용하면 POJO일까 아닐까?
>
> 애너테이션이 단지 코드로 표현하기는 적절치 않은 부가적인 정보를 담고 있고, 환경에 종속되지 않으면 POJO라고 할 수 있다.

> ⚠️
>
> 특정 기술 규약과 환경에 종속되지 않음 모두 POJO일까? (평범한 자바 클래스로만 개발)
>
> 대부분 자바 클래스로만 개발하면 POJO라 착각하기 쉽다.
>
> 객체지향적인 Java 객체는 역할과 책임이 명확히 분리되고, 낮은 결합도를 유지해야 한다. 그러나 하나의 클래스에 다양한 책임과 역할이 몰려 있거나, 강결합을 가지거나, if/switch 문이 과도하게 사용되면 객체지향적인 설계에서 벗어나게 된다. 이러한 경우, 해당 객체를 POJO라고 부르기 어렵다.

`결론`

진정한 POJO란

- 객체지향적인 원리에 충실
- 환경과 기술에 종속되지 않고
- 필요에 따라 재활용될 수 있는 방식으로

설계된 오브젝트이다.

## POJO의 장점

POJO가 될 수 있는 조건 자체가 POJO의 장점이다.

- 특정한 기술과 환경에 종속되지 않는 오브젝트는 그만큼 깔끔한 코드가 될 수 있다.
- 자동화된 테스트에 매우 유리하다.
- 객체지향적인 설계를 자유롭게 적용할 수 있다.

## POJO 프레임워크

스프링은 `POJO`를 이용한 엔터프라이즈 애플리케이션 개발을 목적으로 하는 프레임워크다.

POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크를 POJO 프레임워크라고 한다.

<img width="436" alt="Image" src="https://github.com/user-attachments/assets/77fc3e2e-e72a-47ff-951e-bbf4970db4e3" />

스프링은 `비즈니스 로직의 복잡함`과 `엔터프라이즈 기술의 복잡함`을 분리해서 구성할 수 있게 도와준다.

스프링은 기술 영역에만 관여하고 비즈니스 로직을 담당하는 POJO에서는 모습을 감춘다.

→ POJO 프레임워크로써 스프링은 자신을 직접 노출하지 않으면서 애플리케이션을 POJO로 쉽게 개발할 수 있게 지원해준다.

# 4. 스프링의 기술

---

## 제어의 역전 (IoC) / 의존관계 주입 (DI)

IoC/DI는 스프링의 가장 기본이 되는 기술이자 스프링의 핵심 개발 원칙이다. AOP와 PSA도 IoC/DI에 바탕을 두고 있다.

> ⚠️
>
> new 키워드로 생성해서 사용하는 것보다 `DI를 사용하면` 나은 점이 뭘까?
>
> → “`유연한 확장`이 가능하게 하기 위해서”
>
> DI는 개방 폐쇄 원칙(OCP)이라는 객체지향 설계 원칙으로 잘 설명될 수 있다.
>
> 예시) A→B 의존관계를 갖는 오브젝트 구조
> 
>`확장`
> - B가 자유롭게 변경될 수 있음을 의미한다.
> - B 관점에서는 유연한 확장이고, A 관점에서는 변경 없이 재사용이 가능하다.

## DI의 활용 방법

- **핵심기능의 변경**

DI를 통해 의존 대상의 구현을 바꿀 수 있다.

`example` : A → B

A의 기능 일부를 B에게 위임한다고 했을 때, B의 구현 방식을 필요에 따라 통째로 B1, B2, B3로 바꾸는 것이다.

- **핵심기능의 동적인 변경**

DI는 기본적으로 런타임 시에 동적으로 의존 오브젝트를 연결해주는 것이긴 하지만, 일단 DI 되고 나면 그 후로는 바뀌지 않는다. 즉 동적인 방식으로 연결되지만 한번 DI되면 바뀌지 않는 정적인 관계를 맺어주는 것이다.

- **부가기능의 추가**

인터페이스를 두고 사용하게 하고, 실제 사용할 오브젝트는 외부에서 주입하는 DI를 적용해두면 데코레이터 패턴을 쉽게 적용할 수 있다.

→ 핵심기능과 클라이언트 코드에는 전혀 영향을 주지 않으면서 부가적인 기능을 얼마든지 추가할 수 있다.

- **인터페이스의 변경**

클라이언트가 사용하는 인터페이스와 실제 오브젝트 사이에 인터페이스가 일치하지 않는 경우에도 DI가 유용하게 사용된다.

`example`

- A가 C 오브젝트를 사용하려 한다고 가정한다.
- A는 원래 B 인터페이스를 사용하도록 만들어져 있다.
- C는 B 인터페이스를 구현하지 않았다.

이떄 A가 DI를 통해 B의 구현 오브젝트를 받도록 만들어져 있다면, B 인터페이스를 구현했으면서 내부에서 C를 호출해주는 기능을 가진 어댑터 오브젝트를 만들어 A에 DI해주면 된다.

`A → B(C로 위임) → C`

- **프록시**

`지연 로딩 (Lazy Loading)`을 적용할 때 프록시가 필요하다.

원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게 해주는 원격 프록시를 적용하려고 할 때도 프록시가 필요하다.

- **템플릿과 콜백**

`콜백을 템플릿에 주입`하는 방식으로 동작하게 하는 것은 DI의 원리에 가장 충실한 응용 방법이다.

- **싱글톤과 오브젝트 스코프**

DI 할 `오브젝트의 생명주기`를 제어할 수 있다.

오브젝트의 생성부터 관계설정, 이용, 소멸에 이르기까지의 모든 과정을 DI 컨테이너가 주관하기 때문에 그 `오브젝트 스코프를 자유롭게 제어`할 수 있다.

- **테스트**

여러 오브젝트와 협력해서 동작하는 오브젝트를 효과적으로 테스트하는 방법은 가능한 `고립`시키는 것이다.

그러기 위해서 의존 오브젝트를 대신해서 `스텁(Stub)` 또는 `목(Mock)` 오브젝트 같은 테스트 대역을 활용해야 한다.

## AOP

OOP는 점점 복잡해져 가는 애플리케이션의 요구조건과 기술적인 난해함을 모두 해결하는 데는 한계가 있다.

→ AOP는 바로 이러한 객체지향 기술의 한계와 단점을 극복하도록 도와주는 보조적인 프로그래밍 기술이다.

### AOP 적용 기법

1. 다이내믹 프록시를 사용한다.

스프링의 기본적인 AOP 구현 방법은 다이내믹 프록시를 이용하는 프록시 AOP 방식이다.

1. 자바 언어의 한계를 넘어서는 언어의 확장을 이용한다.

AspectJ라는 유명한 오픈소스 AOP 툴을 사용하여 프록시 방식의 AOP로 할 수 없는 작업의 경우 AspectJ를 사용할 수 있다.

### AOP의 적용 단계

`AOP 적용 1단계 : 미리 준비된 AOP 이용`

일단 처음에는 스프링이 미리 만들어서 제공하는 AOP 기능을 그대로 가져다 적용하는 것으로 시작한다. (ex. `@Transactional`)

`AOP 적용 2단계 : 전담팀을 통한 정책 AOP 적용`

오브젝트에 대한 보안, 특정 계층의 로깅, 데이터 추적을 위한 트레이싱, 특정 구간의 실시간 성능 모니터링과 같은 정책적으로 적용할 만한 기능에 AOP를 이용한다.

`AOP 적용 3단계 : AOP의 자유로운 이용`

첫 번째, 두 번째 단계를 거쳐서 AOP에 어느 정도 친숙해지면, 이젠 개발자가 구현하는 기능에 적용하여 유용한 세부적인 AOP를 이용할 수 있다.

## 포터블 서비스 추상화 (PSA)

> 환경과 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 하는 방식

POJO로 개발된 코드는 특정 환경이나 구현 방식에 종속적이지 않아야 한다.

서비스 추상화를 위해 필요한 기술은 DI뿐이다. DI를 적극 활용해서 개발하면 서비스 추상화는 자연스럽게 만들어 쓸 수 있다.
