# 8장 스프링이란 무엇인가?

## 1. 스프링의 정의

> **자바 엔터프라이즈 개발을 편하게** 해주는 **오픈소스** **경량급** **애플리케이션 프레임워크**
> 

**📍 애플리케이션 프레임워크**

일반적인 라이브러리나 프레임워크나 특정 계층의 한 가지 기술에 집중되는 반면, 스프링은 애플리케이션 개발의 전 과정을 빠르고 편리하게 진행하는 데 목표를 두는 프레임워크다.

**< 탄생 배경 >**

스프링의 기원 : J2EE 기술서적의 예제 코드

처음 만든 사람 : 로드 존슨

→ 이게 발전된 게 스프링 오픈소스 프로젝트 

**📍 경량급**

→ 불필요하게 무겁지 않다.

EJB은 오버 엔지니어링으로 WAS가 무거웠는데, 스프링은 가벼운 톰캣, 제티에서도 잘 동작한다.

즉, 같은 기능을 수행하는 콬드인데도 스프링 코드가 가벼운 이유는 ***코드에 불필요하게 등장하던 프레임워크, 서버환경에 의존하던 부분을 제거해주기 때문***

**📍 자바 엔터프라이즈 개발을 편하게**

EJB도 자바 애플리케이션을 편리하게 개발할 수 있다고 했었다.

> EJB를 사용하면 **애플리케이션 작성을 편하게 할 수 있다**. 로우레벨의 트랜잭션이나 상태 관리, 멀티스레딩, 리소스 풀링과 같은 복잡한 로우레벨의 API 따위를 이해하지 못하더라도 아무런 문제 없이 애플리케이션을 개발할 수 있다.
> 
> 
> - Enterprise JavaBeans 1.0 Specification, Chapter 2 Goals - 
> 

하지만, EJB은 이 과정에서 더 큰 불폄함을 초래했음 

**편리한 애플리케이션 개발?**

개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않으면서 핵심인 요구사항, 비즈니스 로직을 빠르고 효과적으로 구현하는 것 

**📍 오픈소스**

라이선스 : Apache License Ver 2.0

지속적으로 개발되고 문제가 해결될 수 있도록 기업에서 관리한다.

## 2. 스프링의 목적

굳이 스프링을 사용해서 엔터프라이즈 애플리케이션 개발을 편하게 하려는 이유?

→ 원래의 엔터프라이즈 개발은 편하지 않았었기 때문 

### 엔터프라이즈 개발의 복잡함

< 엔터프라이즈 시스템 개발이 복잡한 원인 > 

1. **기술적인 제약조건과 요구사항이 늘어가기 때문**
    
    순수한 비즈니스 로직 이외에도 기술적인 고려사항이 많다.
    
2. 엔터프라이즈 애플리케이션이 구현해야 할 핵심기능인 **비즈니스 로직의 복잡함이 증가하기 때문**
    
    점점 다양하고 복잡함 업무 처리를 담당한다.
    

➡️ 시스템 개발과 유지보수, 추가 개발 등의 작업에 대한 부담이 커지고, 개발의 난이도도 증가함

< 복잡함을 가중시키는 원인 >

비즈니스 로직의 복잡함과 기술적인 복잡함 

### 복잡함을 해결하려는 도전

엔터프라이즈 개발의 근본적인 복잡함은 제거할 수 없다.

결국 그 복잡함을 효과적으로 상대할 수 있는 전략과 기법이 필요하다.

→ 두 가지 복잡함을 분리해야 한다.

< 실패한 해결책 : EJB >

EJB의 기본 전략도 이 두 가지 종류의 복잡함을 분리하는 것이었다.

< 비침투적인 방식을 통한 효과적인 해결책 : 스프링 > 

침투적인(invasive) 기술 : EJB처럼 어떤 기술을 적용했을 때 그 기술과 관련된 코드나 규약이 코드에 등장하는 경우

스프링은 기술적인 복잡함과 비즈니스 로직을 다루는 코드를 분리할 수 있다.

### 복잡함을 상대하는 스프링의 전략

> **스프링 전략**
> 
> 
> 비즈니스 로직을 담은 애플리케이션 코드와 엔터프라이즈 기술을 처리하는 코드를 분리시키는 것 
> 

< 기술적 복잡함을 상대하는 전략 >

스프링은 엔터프라이즈 기술을 적용했을 때 발생하는 복잡함의 문제를 두 가지로 분류했다.

1. 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다.
    
    해결책 : 서비스 추상화
    
    기술적인 복잡함은 **“추상화”**를 통해 **low-level의 기술 구현 부분과, 기술을 사용하는 인터페이스를 분리**하고 **환경과 세부 기술에 독립적인 접근 인터페이스를 제공**하는 것이 가장 좋은 해결책이다.
    
    ex) 트랜잭션 추상화, OXM 추상화, 데이터 액세스에 관한 일관된 예외변환 기능, 데이터 액세스 기술에 독립적으로 적용 가능한 트랜잭션 동기화 기법
    
2. 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다.
    
    해결책 : AOP
    

< 비즈니스 애플리케이션 로직의 복잡함을 상대하는 전략 >

한 때 데이터베이스에 비즈니스 로직을 두는 것이 유행이었지만, 비용과 위험을 인지하고 애플리케이션 안에서 처리하는 추세

< 핵심 도구 : 객체지향과 DI>

DI 바탕의 여러 가지 기법이 활용되지만, 비즈니스 로직 자체의 복잡함을 해결하려면 DI보다는 객체지향 설계 기법이 더 중요하다.

결국 모든 스프링의 기술과 전략은 ‘객체지향’이라는 자바 언어가 가진 가장 강력한 도구를 극대화해서 사용할 수 있도록 돕는 것

## 3. POJO 프로그래밍

스프링의 본질 : 엔터프라이즈 서비스 기능을 POJO에 제공하는 것 

엔터프라이즈 서비스 → 보안, 트랜잭션과 같은 엔터프라이즈 시스템에서 요구되는 기술 

> **스프링의 가장 강력한 특징과 목표**
> 
> 
> 분리됐지만 반드시 필요한 엔터프라이즈 기술을 POJO 방식으로 개발된 애플리케이션 핵심 로직을 담은 코드에 제공한다.
> 

### 스프링의 핵심 : POJO

![image](https://github.com/user-attachments/assets/354edc63-3906-4527-af22-5c869f327dd9)

스프링 애플리케이션

→ **POJO를 이용해서 만든 애플리케이션 코드** + POJO가 어떻게 관계를 맺고 동작하는지 정의해놓은 **설계정보**

IoC/DI, AOP, PSA는 애플리케이션을 POJO로 개발할 수 있게 해주는 가능기술

### POJO란 무엇인가?

> **P**lain **O**ld **J**ava **O**bject
> 

### POJO의 조건

1. 특정 규약에 종속되지 않는다.
    
    📍 POJO는 자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 한다.
    
    특정규약을 따라 만들게 하는 경우는 대부분 규약에서 제시하는 특정 클래스를 상속하도록 요구한다.
    
    → 자바의 단일 상속 제한 때문에 더 이상 클래스에 객체지향적인 설계 기법을 적용하기가 어려워지고, 다른 환경으로 이전하기도 어렵다.
    

1. 특정 환경에 종속되지 않는다.
    
    특히, 비즈니스 로직을 담고 있는 클래스에서는 웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안 된다. (웹 외의 클라이언트는 사용하지 못하게 되기 때문)
    

❌ 특정 기술규약과 환경에 종속되지 않다고 모두 POJO는 아니다. ❌

**진정한 POJO?**

➡️ 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트 

### POJO의 장점

1. 특정한 기술과 환경에 종속되지 않으므로 깔끔한 코드를 작성할 수 있다.
2. 자동화된 테스트에 유리하다.
3. 객체지향적인 설계를 자유롭게 적용할 수 있다.

### POJO 프레임워크

> POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크
> 

ex) 스프링 프레임워크, 하이버네이트

![image](https://github.com/user-attachments/assets/1cbabac0-4921-45db-b297-1f9121a5576e)

스프링은 ***비즈니스 로직의 복잡함***과 ***엔터프라이즈 기술의 복잡함***을 분리해서 구성할 수 있게 해준다.

스프링은 기술 영역에만 관여하고 비즈니스 로직을 담당하는 POJO에는 관여하지 않는다.

## 4.  스프링의 기술

스프링에서 POJO 프로그래밍을 쉽게 할 수 있도록 지원하는 세 가지 가능기술

→ IoC/DI, AOP, PSA

### 제어의 역전(IoC) / 의존관계 주입(DI)

> 두 개의 오브젝트를 분리해서 만들고, 인터페이스를 두고 느슨하게 연결한 뒤, 실제 사용할 대상은 DI를 통해 외부에서 지정하는 이유는?
> 
> 
> 직접 자신이 사용할 오브젝트를 new 키워드로 생성해서 사용하는 강한 결합을 쓰는 방식보다 DI 방식이 더 나은 이유는?
> 

➡️ 유연한 확장이 가능하게 하기 위해서

< DI의 활용 방법 >

DI의 활용 방식은 다양하며, 코드의 유지보수성과 확장성을 극대화할 수 있는 강력한 도구이다.

- 핵심 기능을 쉽게 변경할 수 있으며, 런타임에서도 동적 변경이 가능하다.
- 부가기능을 추가하거나 인터페이스를 변환할 수도 있으며, 프록시 및 템플릿 패턴과도 결합할 수 있다.
- 오브젝트의 생명주기를 컨테이너가 관리하여 성능을 최적화할 수 있으며, 테스트 환경에서도 매우 유용하다.

DI는 단순한 개념이 아니라 애플리케이션 전반에서 설계 원칙을 유지하면서도 유연성을 제공하는 강력한 기법이다.

**📍 핵심 기능 변경**

> 의존 대상의 구현을 바꾸는 것
> 

ex ) 데이터 접근 방식 전체 변경

서비스 객체가 처음에는 **JDBC**를 이용한 DAO를 사용하다가, 이를 **JPA, 하이버네이트, JDO, iBatis** 등으로 변경할 수 있다.

ex) 비즈니스 로직 변경

**사용자의 등급을 결정하는 정책**이 있다면, DI를 통해 새로운 등급 정책 클래스를 적용하면 된다.

**📍 핵심기능의 동적인 변경**

> 런타임 시 의존 객체를 동적으로 변경하는 것
> 

일반적인 DI는 애플리케이션 실행 시 의존 객체를 한 번 설정하면 변경되지 않지만, DI를 잘 활용하면 **애플리케이션이 동작하는 중간에도 동적으로 의존 대상을 변경할 수 있다.**

DI도 기본적으로는 런타임 시에 동적으로 의존 오브젝트를 연결해주지만, 일단 DI 되고 나면 그 후로는 바뀌지 않는다.

ex) 사용자의 등급에 따라 다른 데이터소스를 사용하도록 설정

VIP 사용자는 더 빠른 데이터베이스를 사용하도록 설정하여 성능을 향상시킬 수 있다.

**📍 부가기능 추가**

> 핵심기능은 그대로 둔 채로 부가기능을 추가하는 것
> 

ex) 트랜잭션 기능 추가

ex) 로깅, 보안 처리, 이벤트 발생 기능 추가

**📍 인터페이스 변경**

> 클라이언트와 의존 객체의 인터페이스가 일치하지 않을 때 활용
> 

ex) A가 C를 사용하려 하는데, A는 원래 B 인터페이스를 사용하도록 설계되어 있다면?

**→ B 인터페이스를 구현하면서 내부적으로 C를 호출하는 어댑터 객체**를 만들어 A에게 주입하면 된다. (A→B→C)

**📍 프록시**

**ex) 지연 로딩(Lazy Loading)**

필요한 시점에서만 객체를 생성하고, 초기화할 수 있다.

**ex) 원격 프록시(Remote Proxy)**

네트워크를 통해 원격 객체를 마치 로컬 객체처럼 사용할 수 있도록 해준다.

**📍 템플릿과 콜백**

> 반복적으로 등장하지만 항상 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 템플릿-콜백으로 만들고, DI를 적용하면 코드를 간결하게 만들 수 있다.
> 

ex) 스프링에서는 **JdbcTemplate, RestTemplate, TransactionTemplate** 등 다양한 템플릿을 제공한다.

**📍 싱글톤과 오브젝트 스코프**

> **객체의 생명주기를 DI 컨테이너가 관리**
> 

DI 컨테이너는 객체를 관리하며, 이를 통해 객체의 스코프(Scope)를 제어할 수 있다.

ex) **싱글톤(Singleton) 패턴**을 

전통적인 싱글톤 패턴은 **클래스 내부에서 객체를 생성**하기 때문에 관리가 어렵다.

 → DI 컨테이너를 사용하면 싱글톤 패턴을 쉽게 적용할 수 있다.

**📍 테스트**

> 가능한 한 오브젝트를 고립시켜야 효율적인 테스트가 가능하다.
> 

**ex) Mock 객체를 활용해 테스트**

DI를 활용하면 **테스트 대상을 쉽게 격리**할 수 있다.

DAO를 사용하는 서비스 객체를 테스트할 때, 실제 DAO를 사용하면 **DB가 필요**하여 테스트가 어렵다.

→  **Mock DAO**를 주입한다.

### 애스펙트 지향 프로그래밍(AOP)

AOP를 사용하면 그 결과로 OOP를 더욱 OOP답게 만들 수 있다.

OOP가 **객체 단위로 기능을 분리하는 구조적 접근법**이라면, AOP는 **흩어진 관심사(Cross-Cutting Concerns)를 모듈화하여 코드 중복을 줄이고 유지보수를 용이하게 하는 방식**이다.

**< AOP의 필요성 >**

- OOP만으로는 공통적으로 적용해야 하는 기능(트랜잭션, 로깅, 보안 등) 효율적으로 처리하기 어렵다.
- 코드 중복이 발생하고, **객체 간 결합도가 증가**하여 유지보수가 어려워진다.
- AOP를 사용하면 **핵심 비즈니스 로직과 공통 기능을 분리**하여 OOP의 순수성을 유지할 수 있다.

**< AOP 적용 기법 >**

**📍 Dynamic Proxy 사용**

**데코레이터 패턴을 활용**하여 기존 코드에 영향을 주지 않고 부가 기능을 적용할 수 있다.

**📍 자바 언어 한계를 넘어서는 언어이 확장 이용 : AspectJ를 이용한 AOP 방식**

메서드 호출뿐만 아니라 객체 생성, 필드 접근, 특정 경로에서의 메서드 호출 등 다양한 조인 포인트 제공한다.

별도의 AOP 컴파일러 또는 바이트코드 조작(위빙, weaving)이 필요하여 설정이 복잡하고 부담이 크지만, 프록시 방식의 AOP로 해결할 수 없는 경우 유용하게 사용된다.

**< AOP 적용 단계 >** 

1. 미리 준비된 AOP 이용
    - **트랜잭션(Transaction Management)**
        
        데이터베이스 트랜잭션 관리에 활용되며, `@Transactional` 등의 애너테이션을 이용하여 적용 가능
        
    - **@Configurable**
        
        도메인 객체에 자동으로 DI를 적용하는 기능으로, AspectJ를 필요로 한다.
        
2. 전담팀을 통한 정책 AOP 사용
    - 애플리케이션 전반에 적용하는 공통 정책을 AOP로 관리한다.
    - 보안, 로깅, 트레이싱, 성능 모니터링 등의 기능을 중앙에서 제어한다.
    - 개발자가 직접 보안, 로깅 코드를 추가하지 않아도 되며, 정책 변경이 필요할 경우 AOP 설정만 수정하면 된다.
3. AOP의 자유로운 이용
    
    개발자가 **필요한 곳에 AOP를 직접 적용**하여 공통 기능을 재사용한다.
    
    단, **무분별한 적용을 방지**하기 위해 일정한 가이드라인과 검토 과정이 필요하다.
    

### 포터블 서비스 추상화(PSA)

> 특정 기술이나 환경에 종속되지 않는 방식으로 기술을 추상화하는 개념
> 

즉, 스프링 애플리케이션이 특정 기술(JDBC, JPA, Hibernate 등)에 종속되지 않고, 변경이 용이하도록 하는 전략

1️⃣ **트랜잭션 서비스 추상화**

스프링의 `PlatformTransactionManager` 인터페이스를 이용하여 트랜잭션을 추상화

AOP를 활용하여 트랜잭션을 설정하면, 직접 코드에서 트랜잭션 처리를 하지 않아도 된다.

2️⃣ **OXM, JavaMail 등의 서비스 추상화**

스프링은 다양한 엔터프라이즈 기술(JMS, JPA, JavaMail 등)에 대한 추상 API를 제공한다.

예를 들어, JavaMail을 사용할 때도 직접 API를 다루지 않고, 스프링이 제공하는 추상 API를 활용하면 다양한 메일 서버에서 동일한 코드로 동작한다.

< PSA의 장점 >

- 기술 변경이 용이: 특정 기술(JDBC → JPA)로 변경해도 코드 수정 없이 설정만 변경하면 적용이 가능하다.
- 환경에 독립적인 개발 가능: POJO 기반 개발이 유지되며, 다양한 기술과의 유연한 결합이 가능하다.
- DI를 활용한 서비스 확장성 제공: 필요할 때마다 새로운 기술을 손쉽게 적용할 수 있다.

< PSA 활용 방법 >

1. 스프링이 제공하는 PSA API를 활용한다. (`PlatformTransactionManager`, `MailSender` 등)
2. DI를 이용하여 구체적인 구현체를 설정 파일(XML, JavaConfig)에서 주입한다.
3. PSA 개념을 직접 적용하여, 특정 기술에 의존적이지 않은 서비스 계층을 설계할 수 있다.